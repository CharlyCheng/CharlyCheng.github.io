{"meta":{"title":"CharlyCheng's Blog","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-03-11T07:42:33.185Z","updated":"2019-03-11T07:42:33.184Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"个人简介","date":"2019-03-26T07:07:44.650Z","updated":"2019-03-26T07:07:44.650Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-03-11T07:40:16.369Z","updated":"2019-03-11T07:40:16.369Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-03-11T07:42:33.190Z","updated":"2019-03-11T07:42:33.190Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-03-11T07:39:30.697Z","updated":"2019-03-11T07:39:30.696Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-03-11T07:39:21.832Z","updated":"2019-03-11T07:39:21.831Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-11T07:42:33.194Z","updated":"2019-03-11T07:42:33.194Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"每日一算 -- 斐波那契数列类型题","slug":"每日一算 -- 斐波那契数列类型题","date":"2019-04-09T14:18:49.762Z","updated":"2019-04-09T14:26:02.952Z","comments":true,"path":"2019/04/09/每日一算 -- 斐波那契数列类型题/","link":"","permalink":"http://yoursite.com/2019/04/09/每日一算 -- 斐波那契数列类型题/","excerpt":"","text":"题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 日常找规律 当有1阶时 F(1) = 1 当有2阶时 F(2) = 2(可以1阶或者2阶) 当有3阶时 F(3) = 3(可以1阶或者1、2阶或者2、1) 当有4阶时 F(4) = 5(可以1阶或者1、2、1、1阶或2、1、1、1或2、2、1或2、1、2) … 当有n阶时 F(n) = F(n - 1) + F(n - 2)123F(1)=1F(2)=2F(n)=F(n-1)+F(n-2) 实现方式当我们得到推导公式，实现函数脑海里面会想到递归实现 递归 时间复杂度: O(2^n)123456789function fiber (n) &#123; if ( n === 1) &#123; return 1 &#125; if ( n === 2) &#123; return 2 &#125; return fiber( n - 1) + fiber( n - 2 )&#125; 循环 时间复杂度: O(n) 空间复杂度: O(n)1234567891011121314function fiber (n) &#123; let step = [] step[0] = 1 if ( n &gt;= 2) &#123; step[1] = 2 &#125; if ( n &lt;= 2) &#123; return n &#125; for ( let i = 2; i &lt;= n; i++) &#123; step[i] = step[i - 1] + step[i - 2] &#125; return step[n]&#125; 循环 + 优化空间复杂度 时间复杂度: O(n) 空间复杂度: O(1)1234567891011121314function fiber (n) &#123; let prev1 = 1 let prev2 = 2 let result = 0 if ( n &lt;= 2) &#123; return n &#125; for ( let i = 2; i &lt;= n; i++) &#123; result = prev1 + prev2 prev1 = prev2 prev2 = result &#125; return result&#125; 总结 JavaScript专题之递归 青蛙跳 动态规划","categories":[{"name":"前端学习","slug":"前端学习","permalink":"http://yoursite.com/categories/前端学习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"竟然不会函数节流跟防抖，来看这篇包学包会","slug":"竟然不会函数节流跟防抖，来看这篇包学包会","date":"2019-04-01T12:17:19.642Z","updated":"2019-04-09T13:19:44.811Z","comments":true,"path":"2019/04/01/竟然不会函数节流跟防抖，来看这篇包学包会/","link":"","permalink":"http://yoursite.com/2019/04/01/竟然不会函数节流跟防抖，来看这篇包学包会/","excerpt":"","text":"前言前端开发中会遇到一些频繁的事件触发，比如：window的scroll、resize；mousedown、mousemove，keyup、keydown等等，假如你对自己的代码不做什么的处理，你会发现页面卡顿、触发接口请求频繁等问题，本文将浅析函数节流跟防抖实现，一步一步逐渐揭开函数节流跟防抖的真面目💜 概念理解防抖跟节流触发原理，根据不同使用场景合理使用 函数防抖（debounce）1当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间,不会执行 理解原理:尽管触发事件，但是一定在事件触发 n 秒后才执行，如果在一个事件触发的 n 秒内又触发了这个事件，就以新的事件的时间为准，n秒后才执行，总之，就是要等触发完事件 n 秒内不再触发事件，才会执行! 函数节流（throttle）1预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期 理解原理:规定时间内，保证执行一次该函数 实现防抖根据防抖原理，实现代码如下,之后的示例都将是常规使用:1234567891011121314# 箭头log函数let count = 0const log = () =&gt; &#123; console.log(this) ++count console.log(count)&#125;# 函数表达式const log = function (evt) &#123; console.log(this) console.log(evt) ++count console.log(count)&#125; 123456789const debounce = function (fn, delay)&#123; let timeout = null return function () &#123; if (timeout) &#123; clearTimeout(timeout) &#125; timeout = setTimeout(fn, delay) &#125;&#125; 使用频繁click事件为例常规使用: meContain.onclick = debounce(log, 1000)react demo: …onClick={debounce(log.bind(this), 1000)}通过例子你会发现，1s之内频繁click，都会在最后输出一次log，验证了防抖原理 小伙伴们有没有发现此时的防抖函数仍存在缺陷 this指向和event 对象 假如用户现在一直点击提交按钮的话，就会一直不发出请求，也得不到任何提示，对用户体验相当不好 this指向和event 对象 this指向 log函数中 console.log(this),不使用 debounce 函数的时候，this 的值为：undefined, 这是因为使用了箭头函数，此时需要onClick调用的时候bind(this), this指向react组件示例 常规使用中console.log(this)，不使用 debounce 函数的时候，this 的值为：event 对象 不使用 debouce 函数，会打印 ClickEvent 对象 debounce 函数中，却只会打印 undefined 解决以上问题，来更改我们的代码1234567891011const debounce = function (fn, delay)&#123; let timeout = null return function () &#123; const context = this; const args = arguments; clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; 交互优化体验如果希望立刻执行函数一次，不用等到事件停止触发后才执行，然后等到停止触发 n 秒后，再可以重新触发执行通过添加isImmeDiate来判断是否立刻执行123456789101112131415161718192021const debounce = function (fn, delay,isImmeDiate= false)&#123; let timeout = null return function () &#123; const context = this; const args = arguments; if(timeout) clearTimeout(timeout) if(isImmeDiate) &#123; # 判断是否已经执行过，不要重复执行 let callNow = !timeout timeout = setTimeout(function()&#123; timeout = null; &#125;, delay) if(callNow) result = fn.apply(context, args) &#125; else &#123; timeout = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, delay) &#125; return result &#125;&#125; 如果要添加一个取消debounce开关，只需要添加一个cancle函数清除定时器timeout = null123456789101112131415161718192021222324252627const debounce = function (fn, delay,isImmeDiate= false)&#123; let timeout = null const debounced = function () &#123; const context = this; const args = arguments; if(timeout) clearTimeout(timeout) if(isImmeDiate) &#123; # 判断是否已经执行过，不要重复执行 # setTimeout也是一直在更新的 let callNow = !timeout timeout = setTimeout(function()&#123; timeout = null; &#125;, delay) if(callNow) result = fn.apply(context, args) &#125; else &#123; timeout = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, delay) &#125; return result &#125; debounced.prototype.cancle = function() &#123; clearTimeout(timeout) timeout = null &#125; return debounced&#125; 到这里我们实现了一个防抖函数，但是小伙伴们有没有别的想法呢？ 节流根据节流原理，实现代码如下,之后的示例都将是常规使用: 时间戳实现123456789101112const throttle = function (fn, delay) &#123; let preTime = 0; return function () &#123; const context = this; const args = arguments; const now = +new Date(); if (now - preTime &gt; delay) &#123; fn.apply(context, args); preTime = now; &#125; &#125;&#125; 定时器实现12345678910111213141516171819const throttle = function (fn, delay) &#123; let timeout = null return function () &#123; const context = this; const args = arguments; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null fn.apply(context, args) &#125;, delay) &#125; &#125;&#125;# 如果需要立刻执行，其实变更下执行顺序即可timeout = setTimeout(function()&#123; timeout = null //fn.apply(context, args)&#125;, delay)fn.apply(context, args) 同样使用频繁click事件为例常规使用: meContain.onclick = throttle(log, 1000)通过例子你会发现，频繁click，都会在根据你设定的周期输出一次log，验证了节流原理 小伙伴们有没有发现此时的节流函数存在的特点 时间戳会立刻执行，定时器会在 n 秒后第一次执行 时间戳停止触发后没有办法再执行事件，定时器实现停止触发后依然会再执行一次事件 合并两者特点123456789101112131415161718192021222324252627282930313233const throttle = function (fn, delay) &#123; let timeout = null let preTime = 0; const later = function() &#123; preTime = +new Date() timeout = null fn.apply(context, args); &#125; const throttled = function () &#123; const context = this; const args = arguments; const now = +new Date(); #下次触发fn剩余的时间 const remaining = delay - ( now - preTime) #如果没有剩余的时间了或者系统时间变更 if (remaining &lt;= 0 || remaining &gt; delay) &#123; if(timeout) &#123; clearTimeout(timeout) timeout = null &#125; preTime = now fn.apply(context, args); &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining) &#125; &#125; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125; return throttled&#125; 总结节流，在规定时间内，保证执行一次该函数；防抖，当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时 文档浅谈函数防抖函数节流函数防抖函数节流 自我推荐深入源码了解Vue错误处理Webpack DllPlugin让构建速度柔顺丝滑","categories":[{"name":"前端学习","slug":"前端学习","permalink":"http://yoursite.com/categories/前端学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"浅出Vue errorHandler、errorCaptured错误处理机制","slug":"vue errorHandler、errorCaptured","date":"2019-03-21T04:36:39.685Z","updated":"2019-03-25T06:15:49.843Z","comments":true,"path":"2019/03/21/vue errorHandler、errorCaptured/","link":"","permalink":"http://yoursite.com/2019/03/21/vue errorHandler、errorCaptured/","excerpt":"","text":"引子JavaScript本身是一个弱类型语言，项目中容易发生错误，做好网页错误监控，能帮助开发者迅速定位问题，保证线上稳定。vue项目需接入公司内部监控平台，本人之前vue errorHooks不甚了解, 决定探一探🖼 介绍 errorHandler、errorCaptured文档传送门: errorHandler、errorCaptured errorHandler指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例1234567Vue.config.errorHandler = function (err, vm, info) &#123; #处理错误信息, 进行错误上报 #err错误对象 #vm Vue实例 #`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 #只在 2.2.0+ 可用&#125; 版本分割点 2.2.0 起，捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃 2.4.0 起，也会捕获 Vue 自定义事件处理函数内部的错误 2.6.0 起，也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理 errorCaptured当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播 错误传播规则 默认情况下，如果全局的 config.errorHandler定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报 如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler，不能捕获异步promise内部抛出的错误和自身的错误 一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler 错误信息示例 errorHandler、errorCaptured光说不练，说了白干，呈上结果供各位看官老爷查看 mounted hook 写入未定义的变量，例如：amounted() { a} Vue.config.errorHandler err、vm、info Vue.config.errorHandler 抛出同样的错误 throw errglobalHandleError函数有 e !== err 判断防止log两次错误 Vue.config.errorHandler 抛出新的错误 throw new Error(‘你好毒’) errorCaptured (err, vm, info) =&gt; ?Boolean 类似于React 错误处理边界123&lt;error-boundary&gt; &lt;another-component/&gt;&lt;/error-boundary&gt; 1234567891011121314Vue.component(&apos;ErrorBoundary&apos;, &#123; data: () =&gt; (&#123; error: null &#125;), errorCaptured (err, vm, info) &#123; this.error = `$&#123;err.stack&#125;\\n\\nfound in $&#123;info&#125; of component` return false &#125;, render (h) &#123; if (this.error) &#123; return h(&apos;pre&apos;, &#123; style: &#123; color: &apos;red&apos; &#125;&#125;, this.error) &#125; // ignoring edge cases for the sake of demonstration return this.$slots.default[0] &#125;&#125;) 正文copy 半天官网文档，你是copy忍者吗☺，各位看官老爷，请往下面看，注意自己使用时的Vue版本，避免err抓取不到🖤 解读error.js源码Vue 源码中，异常处理的逻辑放在 /src/core/util/error.js 中 handleError、globalHandleError、invokeWithErrorHandling、logError handleError在需要捕获异常的地方调用。首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法 globalHandleError调用全局的 errorHandler 方法，如果 errorHandler 方法自己又报错了呢？生产环境下会使用 console.error 在控制台中输出 invokeWithErrorHandling更好的异步错误处理，当时写这篇文章时，git history显示小右哥，一周之前敲的代码，瞬间透心凉，心飞扬 logError判断环境，选择不同的抛错方式。非生产环境下，调用warn方法处理错误 errorCaptured 和 errorHandler 的触发时机都是相同的，不同的是 errorCaptured 发生在前，且如果某个组件的 errorCaptured 方法返回了 false，那么这个异常信息不会再向上冒泡也不会再调用 errorHandler 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* @flow */# Vue 全局配置,也就是上面的Vue.configimport config from &apos;../config&apos;import &#123; warn &#125; from &apos;./debug&apos;# 判断环境import &#123; inBrowser, inWeex &#125; from &apos;./env&apos;# 判断是否是Promise，通过val.then === &apos;function&apos; &amp;&amp; val.catch === &apos;function&apos;, val ！=== null &amp;&amp; val !== undefinedimport &#123; isPromise &#125; from &apos;shared/util&apos;# 当错误函数处理错误时，停用deps跟踪以避免可能出现的infinite rendering# 解决以下出现的问题https://github.com/vuejs/vuex/issues/1505的问题import &#123; pushTarget, popTarget &#125; from &apos;../observer/dep&apos;export function handleError (err: Error, vm: any, info: string) &#123; // Deactivate deps tracking while processing error handler to avoid possible infinite rendering. pushTarget() try &#123; # vm指当前报错的组件实例 if (vm) &#123; let cur = vm # 首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。 # 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法 while ((cur = cur.$parent)) &#123; const hooks = cur.$options.errorCaptured # 判断是否存在errorCaptured钩子函数 if (hooks) &#123; # 选项合并的策略，钩子函数会被保存在一个数组中 for (let i = 0; i &lt; hooks.length; i++) &#123; # 如果errorCaptured 钩子执行自身抛出了错误， # 则用try&#123;&#125;catch&#123;&#125;捕获错误，将这个新错误和原本被捕获的错误都会发送给全局的config.errorHandler # 调用globalHandleError方法 try &#123; # 当前errorCaptured执行，根据返回是否是false值 # 是false，capture = true，阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler # 是true capture = fale，组件的继承或父级从属链路中存在的多个 errorCaptured 钩子，会被相同的错误逐个唤起 # 调用对应的钩子函数，处理错误 const capture = hooks[i].call(cur, err, vm, info) === false if (capture) return &#125; catch (e) &#123; globalHandleError(e, cur, &apos;errorCaptured hook&apos;) &#125; &#125; &#125; &#125; &#125; # 除非禁止错误向上传播，否则都会调用全局的错误处理函数 globalHandleError(err, vm, info) &#125; finally &#123; popTarget() &#125;&#125;# 异步错误处理函数export function invokeWithErrorHandling ( handler: Function, context: any, args: null | any[], vm: any, info: string) &#123; let res try &#123; # 根据参数选择不同的handle执行方式 res = args ? handler.apply(context, args) : handler.call(context) # handle返回结果存在 # res._isVue an flag to avoid this being observed，如果传入值的_isVue为ture时(即传入的值是Vue实例本身)不会新建observer实例 # isPromise(res) 判断val.then === &apos;function&apos; &amp;&amp; val.catch === &apos;function&apos;, val ！=== null &amp;&amp; val !== undefined # !res._handled _handle是Promise 实例的内部变量之一，默认是false，代表onFulfilled,onRejected是否被处理 if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(e =&gt; handleError(e, vm, info + ` (Promise/async)`)) # avoid catch triggering multiple times when nested calls # 避免嵌套调用时catch多次的触发 res._handled = true &#125; &#125; catch (e) &#123; # 处理执行错误 handleError(e, vm, info) &#125; return res&#125;#全局错误处理function globalHandleError (err, vm, info) &#123; # 获取全局配置，判断是否设置处理函数，默认undefined # 已配置 if (config.errorHandler) &#123; # try&#123;&#125;catch&#123;&#125; 住全局错误处理函数 try &#123; # 执行设置的全局错误处理函数，handle error 想干啥就干啥💗 return config.errorHandler.call(null, err, vm, info) &#125; catch (e) &#123; # 如果开发者在errorHandler函数中手动抛出同样错误信息throw err # 判断err信息是否相等，避免log两次 # 如果抛出新的错误信息throw err Error(&apos;你好毒&apos;)，将会一起log输出 if (e !== err) &#123; logError(e, null, &apos;config.errorHandler&apos;) &#125; &#125; &#125; # 未配置常规log输出 logError(err, vm, info)&#125;# 错误输出函数function logError (err, vm, info) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; warn(`Error in $&#123;info&#125;: &quot;$&#123;err.toString()&#125;&quot;`, vm) &#125; /* istanbul ignore else */ if ((inBrowser || inWeex) &amp;&amp; typeof console !== &apos;undefined&apos;) &#123; console.error(err) &#125; else &#123; throw err &#125;&#125; 欢乐时光以上是本人对vue 错误处理的浅显理解，欢迎大家交流，共同进步!","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Webpack DllPlugin 让构建速度柔顺丝滑","slug":"webpackDLL","date":"2019-03-13T03:30:49.116Z","updated":"2019-03-24T23:55:37.857Z","comments":true,"path":"2019/03/13/webpackDLL/","link":"","permalink":"http://yoursite.com/2019/03/13/webpackDLL/","excerpt":"","text":"概念DLLPlugin 和 DLLReferencePlugin 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度,将包含大量复用模块且不会频繁更新的库进行编译，只需要编译一次，编译完成后存在指定的文件中。在之后的构建过程中不会再对这些模块进行编译，而是直接使用 DllReferencePlugin 来引用动态链接库的代码。一般会对常用的第三方模块使用这种方式，例如 react、react-dom、lodash 等。只要这些模块不升级更新，这些动态链接库就不需要重新编译。 摘要本文介绍了 Webpack 中 DllPlugin 插件的使用，以及配合使用 AddAssetHtmlPlugin 或者 HtmlWebpackIncludeAssetsPlugin 将构建好的 JS 文件插入到 html页面中 代码地址github: 源码欢迎交流，Star！ 项目目录常规webpack项目，搭建过程本文章不在描述1234567891011myreact|- /build |- webpack.config.js |- webpack.dll.conf.js|- /dist |- dll |- js|- /src |- index.js|- package.json|- index.html 具体项目结构，请看下图 下面开始DLL之旅一.build目录下创建webpack.dll.conf.js(DLLPlugin)12345678910111213141516171819202122232425262728293031const webpack = require(&quot;webpack&quot;)const path = require(&apos;path&apos;)const CleanWebpaclPlugin = require(&apos;clean-webpack-plugin&apos;);const resolve = (dir) =&gt; path.join(__dirname, &apos;..&apos;, dir);module.exports = &#123; entry: &#123; # 将 react、lodash等模块作为入口编译成动态链接库 vendor: [&apos;react&apos;, &apos;react-dom&apos;, &apos;react-router-dom&apos;, &apos;lodash&apos;] &#125;, output: &#123; # 指定生成文件所在目录文件夹， # 将它们存放在了 src 文件夹下 path: resolve(&apos;public&apos;), # 指定文件名 library: &apos;_dll_[name]&apos;, # 存放动态链接库的全局变量名称，例如对应 lodash 来说就是 lodash_dll_lib # 这个名称需要与 DllPlugin 插件中的 name 属性值对应起来 filename: &apos;dll/_dll_[name].[hash].js&apos; &#125;, plugins: [ new CleanWebpaclPlugin([&apos;dll&apos;], &#123; root: resolve(&apos;public&apos;) &#125;), new webpack.DllPlugin(&#123; name: &apos;_dll_[name]&apos;, # 和output.library中一致，值就是输出的manifest.json中的 name值 path: path.join(__dirname, &apos;../public/dll&apos;, &apos;[name].manifest.json&apos;) &#125;) ]&#125; 二. 创建webpack.base.conf.js 使用 DllReferencePlugin123456789101112131415161718192021222324252627282930313233const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);const HTMLWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpaclPlugin = require(&apos;clean-webpack-plugin&apos;);const resolve = (dir) =&gt; path.join(__dirname, &apos;..&apos;, dir);module.exports = &#123; entry: &apos;./src/index.js&apos;, output: &#123; path: resolve(&apos;dist&apos;), filename: &apos;js/[name].[hash].js&apos;, library: &apos;_dll_[name]&apos; &#125;, plugins: [ # 需添加root 否则无法删除，exclude未生效 new CleanWebpackPlugin([&apos;dist&apos;], &#123; root: path.join(__dirname, &apos;..&apos;) &#125;), new HTMLWebpackPlugin(&#123; title: &apos;Webpak DllPlugin 的使用&apos;, template: resolve(&apos;index.html&apos;), filename: &apos;index.html&apos; &#125;), new webpack.DefinePlugin(&#123; &apos;process.env.NODE_ENV&apos;: JSON.stringify(&apos;production&apos;) &#125;), # 告诉 Webpack 使用动态链接库 new webpack.DllReferencePlugin(&#123; // 描述 lodash 动态链接库的文件内容 manifest: require(../public/dll/vendor.manifest&apos;) &#125;) ]&#125; 三、在 index.html 文件中引入动态链接库由于动态链接库我们一般只编译一次，除非依赖的三方库更新，之后就不用编译，因此入口的 index.js 文件中不包含这些模块，所以要在 index.html 中单独引入。 两种方案 手动添加script，手动copy打包好的dll文件夹到dist，麻烦反复，很不爽 使用add-asset-html-webpack-plugin或者html-webpack-include-assets-plugin插入到html中，简单自动化，美滋滋 所以我们肯定会采用第二种方式，下面着重讲下add-asset-html-webpack-plugin与html-webpack-include-assets-plugin插件的使用，项目中使用add-asset-html-webpack-plugin 安装大同小异12npm install add-asset-html-webpack-plugin -Dnpm install html-webpack-include-assets-plugin -D 使用也有相似的地方webpack.base.conf.js 文件中进行使用1234567891011121314151617181920# add-asset-html-webpack-plugin...;const AddAssetHtmlPlugin = require(&apos;add-asset-html-webpack-plugin&apos;);module.exports = &#123; ..., plugins: [ ..., # 给定的 JS 或 CSS 文件添加到 webpack 配置的文件中，并将其放入资源列表 html webpack插件注入到生成的 html 中。 new AddAssetHtmlPlugin([ &#123; # 要添加到编译中的文件的绝对路径 filepath: path.resolve(__dirname,&apos;../public/dll/_dll_vendor.js&apos;), outputPath: &apos;dll&apos;, publicPath: &apos;dll&apos;, includeSourcemap: false &#125; ]) ]&#125; 1234567891011121314151617# html-webpack-include-assets-plugin...;const HtmlWebpackIncludeAssetsPlugin = require(&apos;html-webpack-include-assets-plugin&apos;);module.exports = &#123; ..., plugins: [ ..., # 给定的 JS 或 CSS 文件添加到 webpack 配置的文件中，并将其放入资源列表 html webpack插件注入到生成的 html 中。 new HtmlWebpackIncludeAssetsPlugin([ &#123; assets: [&apos;dll/_dll_vendor.js&apos;], append: false &#125; ]) ]&#125; 两者区别 index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;爱你的一只猫哈哈哈1111&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;root&apos;&gt;&lt;/div&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;dll/_dll_vendor.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/runtime.830efec54753fd6ed91b.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/vendors.830efec54753fd6ed91b.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/app.830efec54753fd6ed91b.js&quot;&gt;&lt;/script&gt; 运行项目1npm run build 查看dist文件下的文件 相关文档webpack 中文","categories":[{"name":"前端学习","slug":"前端学习","permalink":"http://yoursite.com/categories/前端学习/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"leetcode 两数之和/两数相加","slug":"leetCode/两数相加和两数之和","date":"2019-03-11T08:28:34.445Z","updated":"2019-03-26T05:55:54.056Z","comments":true,"path":"2019/03/11/leetCode/两数相加和两数之和/","link":"","permalink":"http://yoursite.com/2019/03/11/leetCode/两数相加和两数之和/","excerpt":"","text":"概要前端对算法的需求一直是最少的，接触的无非是一些冒泡排序之类的简单算法，最近面试感触良多，不说面试算法已经是必考的题目，就说能够加深对Js的理解，也是要仔细看下立个flag，对leetcode Js刷题，估计之后会再用GoLang走一遍 两数之和给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 直观暴力解法，双重循环1234567891011121314/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; for (var j = i+1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] === target) &#123; return [i, j] &#125; &#125; &#125;&#125;; 字典查找整个实现步骤为：先遍历一遍数组，建立map数据，然后再遍历一遍，开始查找，找到则记录index。代码如下：12345678910var twoSum = function(nums, target) &#123; let m = &#123;&#125;; for (var i = 0; i &lt; nums.length; i++) &#123; let tmp = target - nums[i] if (m[tmp] !== undefined) &#123; return [m[tmp], i] &#125; m[nums[i]] = i &#125;&#125;; 两数相加给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 这道题主要考察连接结构，对链表结构并不熟悉，所以想起来有问题，下面的解法有用的位运算符等1234567891011121314151617181920212223242526272829303132333435var addTwoNumbers = function(l1, l2) &#123; var add = 0 , ans , head; while(l1 || l2) &#123; var a = l1 ? l1.val : 0 , b = l2 ? l2.val : 0; var sum = a + b + add; add = ~~(sum / 10); var node = new ListNode(sum % 10); if (!ans) ans = head = node; else &#123; head.next = node; head = node; &#125; if (l1) l1 = l1.next; if (l2) l2 = l2.next; &#125; if (add) &#123; var node = new ListNode(add); head.next = node; head = node; &#125; return ans;&#125;;","categories":[{"name":"算法、数据","slug":"算法、数据","permalink":"http://yoursite.com/categories/算法、数据/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"leetcode 无重复字符的最长子串","slug":"leetCode/无重复字符的最长子串","date":"2019-03-11T07:24:38.612Z","updated":"2019-03-26T05:56:20.133Z","comments":true,"path":"2019/03/11/leetCode/无重复字符的最长子串/","link":"","permalink":"http://yoursite.com/2019/03/11/leetCode/无重复字符的最长子串/","excerpt":"","text":"概要定义两个变量res和left，其中res用来记录最长无重复子串的长度，lefts指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，i - left +１，其中ｉ是最长无重复子串最右边的位置，left是最左边的位置，还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于left，这是由于此时出现过重复的字符，left的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串。最后每次都要在哈希表中将当前字符对应的值赋值为i+1 无重复字符的最长子串给定一个字符串，找出不含有重复字符的最长子串的长度。12345给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 解法一12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;number&#125; */ var lengthOfLongestSubstring = function(s) &#123; let hash = &#123;&#125; let start = 0 let ans = 0 for (var i = 0; i &lt; s.length; i++)&#123; let item = s[i] if (!hash[item]) &#123; hash[item] = true &#125; else &#123; for (;;) &#123; if (s[start] === item) &#123; start++; break; &#125; hash[s[start]] = false start++ &#125; &#125; ans = Math.max(ans, i - start + 1) &#125; return ans &#125; 解法二123456789101112var lengthOfLongestSubstring = function(s) &#123; var res = 0 var left = -1 var m = [] m.fill(-1) for (var i = 0; i &lt; s.length; i++) &#123; left = Math.max(left, m[s.charAt(i)]) m[s.charAt[i]] = i res = Math.max(res, i - left) &#125; return res&#125; 解法三下面这种解法使用了set，核心算法和上面的很类似，把出现过的字符都放入set中，遇到set中没有的字符就加入set中并更新结果res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止：123456789101112131415var lengthOfLongestSubstring = function(s) &#123; var res = 0 var left = 0 var right = 0 var t = new Set() while (right &lt; s.length)&#123; if (!t.has(s.charAt(right))) &#123; t.add(s.charAt(right++)) res = Math.max(res, t.size) &#125; else &#123; t.delete(s.charAt(left++)) &#125; &#125; return res&#125; 两个排序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n))示例：1234nums1 = [1, 3]nums2 = [2]中位数是 2.0 123nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 解题思路这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。但是这道题被定义为Hard也是有其原因的，难就难在要在两个未合并的有序数组之间使用二分法，这里我们需要定义一个函数来找到第K个元素，由于两个数组长度之和的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。下面重点来看如何实现找到第K个元素，首先我们需要让数组1的长度小于或等于数组2的长度，那么我们只需判断如果数组1的长度大于数组2的长度的话，交换两个数组即可，然后我们要判断小的数组是否为空，为空的话，直接在另一个数组找第K个即可。还有一种情况是当K = 1时，表示我们要找第一个元素，只要比较两个数组的第一个元素，返回较小的那个即可。 解法一12345678910var findMedianSortedArrays = function(nums1, nums2) &#123; var s = nums1.concat(nums2); s.sort(function(a, b) &#123; return a - b; &#125;); var len = s.length; if (len &amp; 1) return s[~~(len / 2)]; else return (s[len / 2 - 1] + s[len / 2]) / 2;&#125;; 解法二此题还能用二分搜索法来解，是一种相当巧妙的应用，讲解在这个帖子中写的十分清楚，等有时间我再来写写分析过程：123456789101112131415161718192021222324252627var findMedianSortedArrays = function(nums1, nums2) &#123; var m = nums1.length; var n = nums2.length; if (m &lt; n) &#123; return findMedianSortedArrays(nums2, nums1) &#125; if (n == 0) &#123; return (nums1[(m - 1) / 2] + nums1[m / 2]) / 2.0 &#125; var left = 0, right = 2 * n while (left &lt;= right) &#123; var mid2 = (left + right) / 2; var mid1 = m + n - mid2; var L1 = mid1 == 0 ? 0 : nums1[(mid1 - 1) / 2]; var L2 = mid2 == 0 ? 0 : nums2[(mid2 - 1) / 2]; var R1 = mid1 == m * 2 ? 0 : nums1[mid1 / 2]; var R2 = mid2 == n * 2 ? 0 : nums2[mid2 / 2]; if (L1 &gt; R2) &#123; left = mid2 + 1; &#125;else if (L2 &gt; R1) &#123; right = mid2 - 1; &#125;else &#123; return (Math.max(L1, L2) + Math.min(R1, R2)) / 2; &#125; &#125;&#125;;","categories":[{"name":"算法、数据","slug":"算法、数据","permalink":"http://yoursite.com/categories/算法、数据/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"node 实现图片合成","slug":"node图片合成你可以做到","date":"2018-12-10T08:24:47.007Z","updated":"2019-03-11T08:27:44.421Z","comments":true,"path":"2018/12/10/node图片合成你可以做到/","link":"","permalink":"http://yoursite.com/2018/12/10/node图片合成你可以做到/","excerpt":"","text":"node 实现图片操作在一个偶然的下午，我发现某城同学利用canvas 浏览器端合成图片的项目，遇到性能优化的需求，我觉得后端图片合成可以解决浏览器合成图片延迟问题，因此就私下调研了关于node图片合成相关的技术方案，下面就介绍一下比较流行的解决方案。 目前流行的技术 利用gm库实现图片的压缩，合成等。 利用node-canvas实现node端的canvas绘图。 先说一下第一种，也就是今天要介绍的主角，轻量无痛老牌顺手，值得码农青睐。第二种下次介绍，主要是canvas技术应用。 gm就是GraphicsMagick+ImageMagick。 何为GraphicsMagick？ GraphicsMagick号称图像处理领域的瑞士军刀。 短小精悍的代码却提供了一个鲁棒、高效的工具和库集合，来处理图像的读取、写入和操作，支持超过88种图像格式，包括重要的DPX、GIF、JPEG、JPEG-2000、PNG、PDF、PNM和TIFF。 其实GraphicsMagick是从 ImageMagick 5.5.2 分支出来的，但是现在他变得更稳定和优秀。 何为ImageMagick? ImageMagick是一款创建、编辑、合成，转换图像的命令行工具。支持格式超过 200 种，包括常见的 PNG, JPEG, GIF, HEIC, TIFF, DPX, EXR, WebP, Postscript, PDF, SVG 等。功能包括调整，翻转，镜像(mirror)，旋转，扭曲，修剪和变换图像，调整图像颜色，应用各种特殊效果，或绘制文本，线条，多边形，椭圆和贝塞尔曲线等。 但是对于node来说他们好像帮不上什么忙，因此gm为了node，将二者做了封装。 在开始gm之前首先需要安装GraphicsMagick和ImageMagick，1brew install imagemagick graphicsmagick 安装完毕后，安装gm npm i gm –save 上代码：123456789101112const gm = require('gm')gm('./nodeimg.png') .draw('image Over 46, 706, 102, 102 \"./code.png\"') .draw('image Over 479,704, 152,56 \"./beike.png\"') //.stream() .write(`./output/$&#123;Date.now()&#125;.jpg`, function(err) &#123; if (!err) &#123; console.log('done') &#125;else &#123; console.log(err.message || \"出错了！\"); &#125; &#125;) node执行相关js。成功返回图片信息。 对于图片来说我们会将其存储到cdn中。但是对于我们的业务来说，这个需要结合BUCKY的上传组件，此组件是基于AWS.S3，bucky没有过多阐述相关用法，详细 API 说明可见 http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html。 我们看以下文档发现，s3 上传图片需要一个stream object对象存在。因此我们需要将gm的绘图结果通过stream()API进行转化，实现s3需要的stream对象。上传操作切记需要async/await支持哈。 最终实现就留给大家上手了。 node实践：123456789101112131415const gm = require('gm')let body = gm('./nodeimg.png').draw('image Over 46, 706, 102, 102 \"./code.png\"').draw('image Over 479,724, 152,56 \"./beike.png\"').fontSize(36).font('./font/FZZXHJW.TTF').stroke(\"#999999\",2).drawText(200,764, \"增长线前端出品\") .write(`./output/gm$&#123;Date.now()&#125;.jpg`, function(err) &#123; if (!err) &#123; console.log('done') &#125;else &#123; console.log(err.message || \"出错了！\"); &#125; &#125;) 温馨提示：使用字体时注意版权问题哈。","categories":[{"name":"技术杂记","slug":"技术杂记","permalink":"http://yoursite.com/categories/技术杂记/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"一起来学async/await","slug":"await","date":"2018-11-30T08:08:54.629Z","updated":"2019-03-11T08:33:42.551Z","comments":true,"path":"2018/11/30/await/","link":"","permalink":"http://yoursite.com/2018/11/30/await/","excerpt":"","text":"一道题1234567891011121314151617181920async function async1()&#123; console.log(&apos;1&apos;) await async2() console.log(&apos;2&apos;)&#125;async function async2()&#123; console.log(&apos;3&apos;)&#125;console.log(&apos;4&apos;)setTimeout(function()&#123; console.log(&apos;5&apos;) &#125;,0) async1();new Promise(function(resolve)&#123; console.log(&apos;6&apos;) resolve();&#125;).then(function()&#123; console.log(&apos;7&apos;)&#125;)console.log(&apos;8&apos;) 理解async/await回调函数，事件监听，事件订阅，到 Promise 对象，再到 Generator 函数，追求解决回调地狱的问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748回调函数getData( a =&gt; &#123; getTwoData( a, b =&gt; &#123; getThreeData( b,c =&gt; &#123; getFourData( c, d =&gt; &#123; console.log(&apos;终于嵌套完了&apos;) &#125;) &#125;) &#125;)&#125;)Promise改进后getData().then( a =&gt; &#123; return getTwoData(a)&#125;).then( b =&gt; &#123; return getThreeData(a)&#125;).then( c =&gt; &#123; return getFourData(c)&#125;)Generator function* helloWorldGenerator() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;;&#125;var hw = helloWorldGenerator();hw.next()hw.next()hw.next()Generator 改进后+ co 模块const co = require(&apos;co&apos;);const gen = co(function* () &#123; const a = yield getData(); const b = yield getTwoData(); const c = yield getThreeData(); const d = yield getFourData();&#125;);async/await 改进后async () =&gt; &#123; const a = await getData() const b = await getTwoData() const c = await getThreeData() const d = await getFourData() console.log(d)&#125; asyncasync/await可以说是co模块和生成器函数的语法糖。用更加清晰的语义解决js异步代码。使用 async / await, 搭配 promise, 可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性Promise实现1234567891011121314151617181920212223242526272829303132async function fn(args) &#123; &#125;// 等同于function fn(args) &#123; return sp(function* () &#123; &#125;);&#125;function sp(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; async函数会返回一个Promise对象 – async函数中是return一个值，这个值就是Promise对象中resolve的值； – async函数中是throw一个值，这个值就是Promise对象中reject的值。12345678910111213141516const imAsync = async (num) =&gt; &#123; if (num &gt; 0) &#123; return num // 这里相当于resolve(num) &#125; else &#123; throw num // 这里相当于reject(num) &#125;&#125;imAsync(1).then( v =&gt; &#123; console.log(v);&#125;);// 注意这里是catchimAsync(0).catch( v =&gt; &#123; console.log(v);&#125;) 1234567891011121314151617const imAsync1 = (num) =&gt; &#123; return new Promise ( (resolve, reject) =&gt; &#123; if (num &gt; 0) &#123; resolve(num) &#125; else &#123; reject(num) &#125; &#125;)&#125;imAsync1(1).then( v =&gt; &#123; console.log(v);&#125;);imAsync1(0).catch( v =&gt; &#123; console.log(v);&#125;) awaitawait会暂停当前async函数的执行，等待Promise的计算结果返回以后再继续执行当前的async函数 – await 等待的不是所有的异步操作，等待的只是Promise – await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象 – 任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行12345678910111213141516171819202122const awaitTest = async () =&gt; &#123; console.log(1); await setTimeout(function () &#123; console.log(2); &#125;, 1000); console.log(3);&#125;awaitTest()const awaitTest = async () =&gt; &#123; console.log(1); await new Promise ( (resolve, reject) =&gt; &#123; setTimeout(function () &#123; console.log(2); console.time(&apos;beigin&apos;) resolve() &#125;, 1000); &#125;) console.timeEnd(&apos;beigin&apos;) console.log(3);&#125;awaitTest() async函数对 Generator函数的改进（1）内置执行器Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，（2）更好的语义（3）更广的适用性（4）返回值是 Promise await用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await也可以用于一个同步的值。co 函数库其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库接受 Generator 函数作为参数，返回一个 Promise 对象，不用编写 Generator 函数的执行器 toPromise通过判定参数的类型，然后再通过转移控制权给不同的参数处理函数，从而获取到期望返回的值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function toPromise(obj) &#123; if (!obj) return obj; if (isPromise(obj)) return obj; if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); if (&apos;function&apos; == typeof obj) return thunkToPromise.call(this, obj); if (Array.isArray(obj)) return arrayToPromise.call(this, obj); if (isObject(obj)) return objectToPromise.call(this, obj); return obj;&#125;function objectToPromise(obj)&#123; //获取一个和传入的对象一样构造器的对象 var results = new obj.constructor(); //获取对象的所有可以遍历的key var keys = Object.keys(obj); var promises = []; for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; //每一个项都调用一次toPromise方法，变成Promise对象 var promise = toPromise.call(this, obj[key]); //如果里面是Promise对象的话，则取出e里面resolved后的值 if (promise &amp;&amp; isPromise(promise)) defer(promise, key); else results[key] = obj[key]; &#125; //并行，按顺序返回结果，返回一个数组 return Promise.all(promises).then(function () &#123; return results; &#125;); function defer(promise, key) &#123; results[key] = undefined; promises.push(promise.then(function (res) &#123; results[key] = res; &#125;)); &#125;&#125;function thunkToPromise(fn) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; fn.call(ctx, function (err, res) &#123; if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); &#125;); &#125;);&#125;function arrayToPromise(obj) &#123; return Promise.all(obj.map(toPromise, this));&#125;function isPromise(obj) &#123; return &apos;function&apos; == typeof obj.then;&#125;function isGenerator(obj) &#123; return &apos;function&apos; == typeof obj.next &amp;&amp; &apos;function&apos; == typeof obj.throw;&#125;function isGeneratorFunction(obj) &#123; var constructor = obj.constructor; if (!constructor) return false; if (&apos;GeneratorFunction&apos; === constructor.name || &apos;GeneratorFunction&apos; === constructor.displayName) return true; return isGenerator(constructor.prototype);&#125;function isObject(val) &#123; return Object == val.constructor;&#125; async/await 错误处理12345678async function f() &#123; await Promise.reject(&apos;出错了&apos;);&#125;f().then(v =&gt; console.log(&apos;1&apos;, v)).catch(e =&gt; console.log(&apos;错误&apos;, e))// 出错了 123456789async function f() &#123; let a = await Promise.reject(&apos;hello world1&apos;); let b = await Promise.resolve(&apos;hello world2&apos;); // 不会执行 console.log(a, b)&#125;f().then(v =&gt; console.log(&apos;1&apos;, v)).then(v =&gt; console.log(&apos;2&apos;, v)).catch(e =&gt; console.log(&apos;错误&apos;, e)) 12345678910async function f() &#123; try &#123; await Promise.reject(&apos;出错了&apos;); &#125; catch(e) &#123; &#125; return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v)) 12345678910async function f() &#123; await Promise.reject(&apos;出错了&apos;) .catch(e =&gt; console.log(e)); return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 如果有多个await命令，可以统一放在try…catch结构中。12345678910111213async function main() &#123; try &#123; const val1 = await Promise.reject(&apos;出错了&apos;); const val2 = await Promise.resolve(&apos;爱你1&apos;); const val3 = await Promise.resolve(&apos;爱你2&apos;); console.log(&apos;Final: &apos;, val2); &#125; catch (err) &#123; console.error(&apos;error&apos;, err); &#125;&#125;main() try…catch结构，实现多次重复尝试 12345678910111213const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await Promise.resolve(&apos;出错了&apos;); break; &#125; catch(err) &#123;&#125; &#125; console.log(i);&#125;test(); 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发1let [foo, bar] = await Promise.all([getFoo(), getBar()]);","categories":[{"name":"前端学习","slug":"前端学习","permalink":"http://yoursite.com/categories/前端学习/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"Promise实践","slug":"promise实践分享","date":"2018-11-27T09:28:03.417Z","updated":"2019-03-11T08:27:50.687Z","comments":true,"path":"2018/11/27/promise实践分享/","link":"","permalink":"http://yoursite.com/2018/11/27/promise实践分享/","excerpt":"","text":"promise学习笔记一 JS异步： 1、 回调函数 2、事件发布/订阅模式（观察者模式） 3、使用Promise对象 4、使用Generator函数 5、使用async函数 …等等 Promise 是异步编程的一种解决方案。解决了代码缩进的金字塔问题 二 实现方式： 用 new Promise 方法创建promise对象 用.then 或 .catch 添加promise对象的处理函数 基本写法： const promise =newPromise(function(resolve, reject){ // ... some code if(/* 异步操作成功 */){ resolve(value); }else{ reject(error); } }); promise.then(res =&gt;{}).catch(err=&gt;{}) 三 三种状态 从Pending转换为Fulfilled或Rejected之后， 这个promise对象的状态就不会再发生任何变化 var promise =newPromise(function(resolve){ resolve(42); reject(30) }); promise.then(function(value){ console.log(value); }).catch(err =&gt;{ console.log(err) }); 四 用return 替代*resolve 无法改变状态 无法链式调用 const testReturn =(a)=&gt;{ returnnewPromise((resolve,reject)=&gt;{ if(a){ return&apos;this is return&apos;; //resolve(&apos;true&apos;); }else{ reject(&apos;false&apos;); } }) } testReturn(true).then(res =&gt;{console.log(res)}) 拿不到return结果，且promise状态不会变，依然是pending状态。 五 用throw 代替 reject promise对象也变为Rejected状态，但是throw Error不会被catch的 const testReturn =(a)=&gt;{ returnnewPromise((resolve,reject)=&gt;{ if(a){ thrownewError(&apos;error&apos;); //reject((&apos;error&apos;) } }) } testReturn(true).catch(res =&gt;{console.log(res)}) 六 代码执行顺序问题new Promise是同步的，会马上执行function参数中的代码。等function参数执行完，new Promise才返回一个promise实例对象。这时候再调用then，其实是已经fullfill了 简单例子： var promise =newPromise(function(resolve){ console.log(&quot;inner promise&quot;);// 1 resolve(42); }); promise.then(function(value){ console.log(value);// 3 }); console.log(&quot;outer promise&quot;);// 2 newPromise(resolve =&gt;{ console.log(1); resolve(3); Promise.resolve().then(()=&gt; console.log(4)) }).then(num =&gt;{ console.log(num) }); console.log(2); 当promise遇到setTimeout, resolve会将Promise.then放在微任务队列中。而setTimeout 属于 macrotask 宏任务。 浏览器的一个事件循环中只有一个macrotask任务，可以有一个或多个microtask任务。 promise队列中任务执行完毕，再执行setTimeout的任务队列。 首先，setTimeout 被推进到 macrotask 队列(将在下一个macrotask中执行)中 -&gt;先执行 macrotask 中的第一个任务（整个script中的同步代和promise 构造函数 ）-&gt;promise.then 回调被推进到 microtask 队列中 (此时，已经执行完了第一个 macrotask) , -&gt;顺序执行所有的 microtask, (也就是 promise.then 的回调函数)。 此时，microtask 队列中的任务已经执行完毕，执行剩下的 macrotask 队列中的任务setTimeout. setTimeout(function(){ console.log(4) },0); newPromise(function(resolve){ console.log(1) for(var i=0; i&lt;10000; i++){ i==9999&amp;&amp; resolve(5) } console.log(2) }) .then(function(res){ console.log(res) }); console.log(3); 另一种情况: resolve在setTimeout中 1-&gt;2-&gt;4(宏任务结束)-&gt;3(微任务结束) const testReturn =(a)=&gt;{ returnnewPromise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ if(a){ resolve(3); console.log(2); }else{ reject(&apos;false&apos;); } }) console.log(1); }) } testReturn(true).then(str=&gt;{ console.log(str); // console.log(testReturn) }).catch(err=&gt;{ console.log(&apos;err: &apos;,err); }) 当有Error的时候，Error后面的代码不会被执行，但是Promise的结果依旧是fulfilled const testReturn =(a)=&gt;{ returnnewPromise((resolve,reject)=&gt;{ if(a){ resolve(&apos;exec true&apos;); console.log(&apos;this will be exec&apos;); thrownewError(&apos;error&apos;); console.log(&apos;this will not be exec&apos;) }else{ reject(&apos;false&apos;); } }) } testReturn(true).then(str=&gt;{ console.log(str); // console.log(testReturn) }).catch(err=&gt;{ console.log(&apos;err: &apos;,err); }) 七 cacth() 和 then(null, ..) 使用promise.then(onFulfilled, onRejected) : 在 onFulfilled 中发生异常的话，在 onRejected 中捕获不到这个异常。 使用 promise.then(onFulfilled).catch(onRejected) 的情况下: then 中产生的异常能在 .catch 中捕获 所以，cacth() 和 then(null, ..)并不完全相同 function throwError(value){ // 抛出异常 thrownewError(value); } // &lt;1&gt; onRejected不会被调用 function badMain(onRejected){ returnPromise.resolve(42).then(throwError, onRejected); } // &lt;2&gt; 有异常发生时onRejected会被调用 function goodMain(onRejected){ returnPromise.resolve(42).then(throwError).catch(onRejected); } // 运行示例 badMain(function(){ console.log(&quot;BAD&quot;); }); goodMain(function(){ console.log(&quot;GOOD&quot;); }); 八 chain 链式调用 在 then 方法内部，我们可以做三件事： return 一个 promise 对象 return 一个同步的值或者是 undefined 同步的 throw 一个错误 传给每个then 方法的value 的值都是前一个promise对象通过return 返回的值。实现依赖于 then 方法每次都会创建并返回一个新的promise对象 var aPromise =newPromise(function(resolve){ resolve(100); }); aPromise.then(function(value){ return value *2; }); aPromise.then(function(value){ return value *2; }); aPromise.then(function(value){ console.log(&quot;1: &quot;+ value);// =&gt; 100 }) var bPromise =newPromise(function(resolve){ resolve(100); }); bPromise.then(function(value){ return value *2; }).then(function(value){ return value *2; }).then(function(value){ console.log(&quot;2: &quot;+ value);// =&gt; 100 * 2 * 2 }); then的错误写法：promise.then 中产生的异常不会被外部捕获，此外，即使 then有返回值，也拿不到返回值。 function badAsyncCall(){ var promise =Promise.resolve(&apos;111&apos;); promise.then(function(){ // 任意处理 return&apos;222&apos;; }); return promise; } badAsyncCall().then(res =&gt;{console.log(res)}) function anAsyncCall(){ var promise =Promise.resolve(&apos;111&apos;); return promise.then(function(){ // 任意处理 return&apos;222&apos;; }); } anAsyncCall().then(res =&gt;{console.log(res)}) 九 then同时处理多个异步请求: Promise.all 在接收到的所有的对象promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理， Promise.all() 以一个 promise 对象组成的数组为输入，返回另一个 promise 对象。这个对象的状态只会在数组中所有的 promise 对象的状态都变为 resolved 的时候才会变成 resolved。可以将其理解为异步的 for 循环。 Promise.race() 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理，那个率先改变的Promise 实例的返回值，就传递给回调函数。romise.race 在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行 var winnerPromise =newPromise(function(resolve){ setTimeout(function(){ console.log(&apos;this is winner&apos;); resolve(&apos;this is winner&apos;); },4); }); var loserPromise =newPromise(function(resolve){ setTimeout(function(){ console.log(&apos;this is loser&apos;); resolve(&apos;this is loser&apos;); },1000); }); // 第一个promise变为resolve后程序停止 Promise.race([winnerPromise, loserPromise]).then(function(value){ console.log(value);// =&gt; &apos;this is winner&apos; }); // promise.all 解决 forEach问题 var winnerPromise =newPromise(function(resolve){ resolve([1,2,3,4,5,6]) }); //错误 winnerPromise.then(function(result){ result.forEach(function(row){ return result }); }).then(function(res){ console.log(res) // I naively believe all docs have been removed() now! }); //正确 winnerPromise.then(function(result){ returnPromise.all(result.map(function(row){ return result })); }).then(function(res){ console.log(res) // All docs have really been removed() now! }) 十 new Promise的快捷方式 function p (num){ if(num &gt;=0){ returnPromise.resolve(num) }else{ returnPromise.reject(newError(&apos;参数不能小于 0&apos;)) } } p.then(res=&gt;{console.log(res)})","categories":[{"name":"技术杂记","slug":"技术杂记","permalink":"http://yoursite.com/categories/技术杂记/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"利用VW，Rem实现前端页面的自适应方案","slug":"利用VW，Rem实现前端页面的自适应方案","date":"2018-10-24T06:52:48.466Z","updated":"2019-03-11T08:27:56.123Z","comments":true,"path":"2018/10/24/利用VW，Rem实现前端页面的自适应方案/","link":"","permalink":"http://yoursite.com/2018/10/24/利用VW，Rem实现前端页面的自适应方案/","excerpt":"","text":"==题记==：目前增长团队手机端适配方案不统一，应对WAP页面的需求开发，怎么解决？标准统一对于后续开发迭代很关键，所以基于这个出发点前端团队提出需要制定相关技术标准方案。其中今天说到的关于移动端适配就是我们开始的第一步。 技术背景 1.响应式web设计能做什么？ 让一个网站同时适配多种设备和多个屏幕，可以让网站的布局和功能随用户的使用环境（屏幕大小、输入方式、设备/浏览器能力）而变化。 2.什么是viewport？ 浏览器中用于呈现网页的区域叫视口（viewport）视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下。为了解决前面的问题，可以在网页的中添加下面这行代码： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui&quot;&gt; 3.Rem,Vw具体指的是什么？ rem的——“font size of the root element” viewport宽度有关，100%视口宽度 = 100vw [vw兼容性] 技术方案==利用Rem Vw 实现响应式布局的基准== ++实现方案：++ 利用less的函数方式实现相关转换假定对应的设计稿750px宽的，100vw,那么量出来的宽度直接用less中定义的函数解决就好：123456789101112@clientW:750;.pxtovw(@value) &#123; @pxtovw:100vw*@value/@clientW; @pxtorem:@value/100rem;&#125;//具体使用方式.blk_main&#123; .pxtovw(750); min-width:@pxtorem; min-width:@pxtovw;&#125; 纯css3属性实现无需编译 (基于rem的 设计稿750宽，假定字体大小100px) 1.通用方案 rem js实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647(function(doc, win,baseDesignValue) &#123; var Dpr = 1, uAgent = window.navigator.userAgent; var isIOS = uAgent.match(/iphone/i); var is2345 = uAgent.match(/Mb2345/i); var ishaosou = uAgent.match(/mso_app/i); var isSogou = uAgent.match(/sogoumobilebrowser/ig); var isLiebao = uAgent.match(/liebaofast/i); var isGnbr = uAgent.match(/GNBR/i); function resizeRoot() &#123; var wWidth = (screen.width &gt; 0) ? (window.innerWidth &gt;= screen.width || window.innerWidth == 0) ? screen.width : window.innerWidth : window.innerWidth, wDpr, wFsize; var wHeight = (screen.height &gt; 0) ? (window.innerHeight &gt;= screen.height || window.innerHeight == 0) ? screen.height : window.innerHeight : window.innerHeight; if (window.devicePixelRatio) &#123; wDpr = window.devicePixelRatio; &#125; else &#123; wDpr = isIOS ? wWidth &gt; 818 ? 3 : wWidth &gt; 480 ? 2 : 1 : 1; &#125; if (isIOS) &#123; wWidth = screen.width; wHeight = screen.height; &#125; if (wWidth &gt; wHeight) &#123; wWidth = wHeight; &#125; wFsize = wWidth &gt; 540 ? 72 : wWidth*100 / baseDesignValue; wFsize = wFsize &gt; 32 ? wFsize : 32; window.screenWidth_ = wWidth; if (is2345 || ishaosou || isSogou || isLiebao || isGnbr) &#123; //这里有个刚调用系统浏览器时候的bug，需要一点延迟来获取 setTimeout(function() &#123; wWidth = (screen.width &gt; 0) ? (window.innerWidth &gt;= screen.width || window.innerWidth == 0) ? screen.width : window.innerWidth : window.innerWidth; wHeight = (screen.height &gt; 0) ? (window.innerHeight &gt;= screen.height || window.innerHeight == 0) ? screen.height : window.innerHeight : window.innerHeight; wFsize = wWidth &gt; 540 ? 72 : wWidth / 7.5; wFsize = wFsize &gt; 32 ? wFsize : 32; document.getElementsByTagName(&apos;html&apos;)[0].style.fontSize = wFsize + &apos;px&apos;; &#125;, 500); &#125; else &#123; document.getElementsByTagName(&apos;html&apos;)[0].style.fontSize = wFsize + &apos;px&apos;; &#125; // alert(&quot;fz=&quot;+wFsize+&quot;;dpr=&quot;+window.devicePixelRatio+&quot;;UA=&quot;+uAgent+&quot;;width=&quot;+wWidth+&quot;;sw=&quot;+screen.width+&quot;;wiw=&quot;+window.innerWidth+&quot;;wsw=&quot;+window.screen.width+window.screen.availWidth); &#125; if (!doc.documentElement.addEventListener) return; doc.addEventListener(&apos;DOMContentLoaded&apos;, resizeRoot, false); resizeRoot(); &#125;)(document, window,750); 2.激进的方案：rem + vw + 1000px宽设计稿 123456789101112131415161718192021222324252627@clientW:1000;.pxtovw(@value) &#123; @pxtovw:100vw*@value/@clientW; //@value/10 @pxtorem:@value/100rem;&#125;html &#123; height: 100%; font-size: 10vw; //100vw *100px/1000px line-height: 1; max-width: 750px; overflow-x: hidden; font-family: Microsoft YaHei, STHeiti, Helvetica, Arial, sans-serif!important&#125;.blk-main&#123; .pxtovw(640); min-width:@pxtorem; min-width:@pxtovw;&#125;最终??优化： 属性值： vw =&gt; 除以10 单位vw rem =&gt; 除以100 单位rem 最终如果要兼容低版本终端，我建议就使用REM就够了，VW也只是一个新的方法。","categories":[{"name":"技术杂记","slug":"技术杂记","permalink":"http://yoursite.com/categories/技术杂记/"}],"tags":[{"name":"移动端自适应","slug":"移动端自适应","permalink":"http://yoursite.com/tags/移动端自适应/"}]}]}